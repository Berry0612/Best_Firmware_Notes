## 0X10同樣概念但不同題型:

- 在嵌入式開發中，我們經常需要定義時間相關的參數。假設我們現在正在開發一個基於 16-bit 架構 的微控制器系統。

  請你使用 #define 宣告一個名為 TICKS_PER_DAY 的巨集常數，用來表示一天內總共有多少個系統 tick。

  假設我們的系統時鐘頻率是 1 kHz（也就是每秒 1000 個 tick）。

  請寫出這行程式碼，並簡短說明你的寫法理由。」

### 我的答案:
```c
#define TICKS_PER_DAY(1000*60*60*24)UL

//U=unsign;代表不帶負號的整數，因此可獲得更大的定義範圍，如32bit的系統可獲得 2^32= 4294967296的整數表示。
//L=long;在某些編譯器裡，他和int一樣代表4byte，但在有些如16bit系統裡，可能int=2bytes ,他會等於4bytes。
//當我們加入UL可以有更好的裝置移植性。
```
### 正確答案:
  ```c
#define TICKS_PER_DAY  (1000UL * 60UL * 60UL * 24UL)
  ```
### #錯誤解析
1.巨集名稱要和左括號之間留有空白

2.UL要接在常數後面

---

- 在嵌入式系統中，為了節省函式呼叫（Function Call）的效能損耗，我們有時會用巨集來寫一些簡單的數學運算，類似 Inline Function 的概念。

  請你寫一個名為 MAX 的巨集，它接收兩個參數 A 和 B，並回傳其中較大的那個數值。

  寫完後，請告訴我：如果我這樣呼叫你的巨集：MAX(*ptr++, 5)，會發生什麼潛在問題？」

  ```c
  #define MAX(a,b)= (a>b) ? a : b

  MAX(*ptr++, 5);
  // =(*ptr++>5) ? *ptr++ : 5
  //假設*ptr++完等於8，然後判斷式為正確所以回傳*ptr++ ，但是這裡會變成多加一次，所以變成9。
  ``` 
### 正確答案:
  ```c
#define MAX(A, B)   ((A) > (B) ? (A) : (B))
  ```
### #錯誤解析
1.括弧要括好，假設A= x&2 ，判斷式變成 x & 2 > 3，因為 > 優先權高於 & ，所以會錯亂。

2.要永遠記住#define 這種是巨集替換 所以不該加 "=" ，只要空格就好。 

---

- 接著我們來談談變數的生命週期與可視範圍（Scope），這是模組化設計的基礎。

  請告訴我，關鍵字 static 在 C 語言中有哪三種主要的用途？ 為了讓我知道你真的理解，請分別舉例說明：

  1.在函式內部（Function body）**宣告 static 變數。

  2.在模組內（Module/File level，但在函式外）**宣告 static 變數。

  3.在模組內宣告 static 函式。

  它們分別會有什麼行為？」

### 我的答案:

  1.在函式內部宣告static變數，該變數的存在週期只會在該函數內。
  
  2.在檔案內函數外宣告static變數，等於可以在檔案內宣告同名的變數。
  
  5.等於隱藏該變數無法讓其他檔案儲存。

### 正確答案:
  1."函數"內的static"變數"：變數的值在函式呼叫後不會消失。
  
  2."區域"內的static"變數"：變數無法在其他檔案透過extern存取他。
  
  3."區域"內的static"函式"：該函式只能被同一檔案的其他函式呼叫。

### #錯誤解析
  1.正常的變數在函式內呼叫本來就會消失，所以加入static才不會消失阿! --> 那函式內的呼叫，外部檔案可以extern存取他嗎?
  
  2.應該要強調"區域外"可以用同名，例如: 
  ```C
int a = 50;       // 全域變數
void foo(void) {
static int a = 3; // 區域靜態變數
  }
  ```
  但是這也不重要，應為正常情況下的變數都可以。
  
  所以他的特點就會是無法讓其他檔案透過extern存取他，也就是隱藏起來。
  
  3.可能當下不太清楚static在"函式"的用法，下面是例子:
  ```C
#include <stdio.h>

static void secret() {
    printf("This is a static function, only visible in this file.\n");
}

void call_secret() {
    secret();  // OK
}
  ```

---
- 請解釋 volatile 這個關鍵字的含義。 並且，請列舉 三種 務必要使用 volatile 的具體場景（Scenario）。」
- 
### 我的答案:
  volatile 提醒編譯器，不要對該變數做最佳化，每次都要重新讀取他的值。
  
  例子:
  
  1.周邊裝置的硬體暫存器，透過高低電位決定狀態，如果該程式的變數指向該暫存器的記憶體位置，那就會影響該程式變數。
  
  2.中斷程式會改動到的變數。
  
  3.多執行緒下，多個程式共享的變數。
  
### 補充:
volatile 告訴編譯器，該變數的值可能會被其他因素改變，因此不該對其進行最佳化，每次存取都須要直接讀取記憶體資料。 

```c
///可能會最佳會為while(1)
int flag = 0; //正確為:volatile int flag = 0;

int main() {
    while (flag == 0) { 
        // 等中斷改變 flag
    }
}
```
當flag應為中斷程式改變數值時，如果沒有加入volatile，while迴圈可能被最佳化成無限迴圈。

例2:

ISR 中會存取到的"非自動變數"（Non-automatic variables）」或是「全域變數（Global variables）」。

自動變數如下:
```c
void foo() {
    int x = 10;   // automatic variable
}
```
函數結束就會被回收。

非自動變數如下:

- 全域變數

- static 變數（無論在函數內或函數外）

- 記憶體映射暫存器

- heap 分配的變數（比較少用在 ISR）

這些變數的特性是：

  在 ISR 執行時仍然存在，可以被 ISR 修改或讀取。

---
請問：一個變數可以同時是 const 也是 volatile 嗎？ （例如：const volatile int x;）

如果是，請舉一個實際的例子說明為什麼會有這種怪異的組合。

如果否，請解釋為什麼這兩個關鍵字互斥。」

### 我的答案:
  可以，當我要定義某個只能唯讀但是數值可能會變動的變數時，我可以用const volatile int 變數。 
  
  例1: #define ADC_DR   (*(const volatile uint32_t*) 0x4001244C )
       這個數值會被"硬體"更新，不能用最佳化，且不想被寫入。


      

 







   



