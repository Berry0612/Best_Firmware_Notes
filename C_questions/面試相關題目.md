你好，我是今天的面試官。很高興看到你有備而來。

既然你是應徵韌體工程師，C 語言的底層觀念對我們來說至關重要。我們不會只考語法，更看重你對編譯器行為和硬體互動的理解。我已經看過你搜集的題庫，我們會依照這些重點概念來進行測驗。

那我們就直接開始吧。

【第一題：C 語言關鍵字】

請你分別解釋 const、static 以及 volatile 這三個關鍵字在 C 語言中的意義與用途。

特別針對 volatile，請告訴我：在韌體（Firmware）開發的場景下，什麼時候我們「必須」使用它？如果不使用會發生什麼事？

回答:
1.const 代表該變數為唯讀，只能讀取其中數值而不能修改

2.static 在函數內宣告，代表即使函數結束，該變數的生存週期依然存在。

對於別的檔案來說static可以隱藏該函數，使得別的檔案無法 extern 存取他。

3.volatile 提醒編譯器不要最佳化該變數，而是每次讀取都要重新訪外該記憶體。

如果沒有 volatile 在有些情況下編譯器會自行優化成非預期行為，例如使用while迴圈，設定變數flag等於1，放進while迴圈中，編譯器可能會認為該迴圈就是無限迴圈，事實上，也許有放ISR程序控制flag的參數，但是如果沒有volatile的話，就會變成無限迴圈。

#補充

1. 使用const儲存常量會被放置在flash中，節省SRAM空間，但是犧牲效能。

2. 

3. volatile
   - Memory-Mapped I/O（存取硬體暫存器）: 周邊裝置的硬體暫存器會被高低電位影響數值。
   - 多執行緒（Multi-thread）共用的 Global Variable（視架構與同步機制而定）。
    
---
【第二題：指標與運算優先級】
好，確認完關鍵字觀念後，我們來看記憶體操作。這也是你提供的資料中提到的重點 。

請看以下這段 C 語言程式碼。假設 int 為 4 bytes，ptr 的初始位址為 0x1000。

```c
int arr[] = {10, 20, 30, 40, 50};
int *ptr = arr;

int a = *(ptr++);
int b = *(++ptr);
int c = ++(*ptr);
```

請告訴我：

1.執行完這三行後，變數 a, b, c 的值分別是多少？

2.最後 ptr 指向的記憶體位址變成了多少（以 Hex 表示，假設初始是 0x1000）？

3.此時陣列 arr 的內容有沒有發生變化？如果有，變成了什麼？

回答:

1. a = 20 , b = 20 , c = 11

2. 0x1004

3.沒有 

正確答案:

1.a = 10, b = 30, c = 31

2.最後 ptr 指向 0x1008 (指到了 arr[2])

3.陣列 有 發生變化。arr[2] 從 30 變成了 31。

#錯誤解析

1.
- ptr++ 是後置遞增，意思是"先做後加" ，所以應該先指向10，a等於10，而後指向下一位20 。

- 這裡沒有意思到這是完整的程式題， 2.3. 要接續1.的回答。 前置遞增先加後做。 所以指向30。

- 前置遞增且在指標括弧外，所以當前指標+1，等於31

2. 0x1000 : arr[0]起始位置 --> 0x1004 arr[1]起始位置 --> 0x1008 arr[2]起始位置。      

3. 遞增在括弧內代表指標指向的位址發生變化，在括弧外的話，指標指向的位址不變但值會發生變化。

---
### 【第三題：位元運算 (Bitwise Operation) 與巨集 (Macro)】

這是韌體工程師吃飯的工具，幾乎每天都會用到。

請寫出一個 C 語言的 **Macro (巨集)**，名稱為 `BIT_OP(addr, bit, op)`。
這個 Macro 接受三個參數：

1.  `addr`: 變數的位址（或者是暫存器的值）。
2.  `bit`: 第幾個 bit (0-31)。
3.  `op`: 操作模式，1 代表 **Set (設為1)**，0 代表 **Clear (設為0)**。

**題目要求：**
請利用位元運算子（`&`, `|`, `~`, `<<` 等）實作這個邏輯，讓我可以這樣呼叫：

```c
int reg = 0x00;
BIT_OP(reg, 3, 1); // 將 reg 的第 3 個 bit 設為 1 -> reg 變 0x08
BIT_OP(reg, 3, 0); // 將 reg 的第 3 個 bit 清除為 0 -> reg 變 0x00
```

(請試著寫出這行 `#define ...`)

我的答案:
#define BIT_OP(addr, bit, op) {
if (op == 1) addr |= (1<<bit);
else if (op == 0) addr &= ~(1<<bit);
}

### marco注意重點!!!
1. 在marco中的參數最好用括號保護。
2. marco是文字替換，使用{}括弧可能導致語法錯誤，所以不使用if else 而是do{}while(0) 或是 a ? b : c
3. 數值需要加UL以免溢位。

4. 如果後面空白要接續的話加上 "\"
5. 也可以不用加空白讓他在同一行，寫法一樣只是不建議。


### 

```c
// 使用 do-while(0) 確保語法安全，並加上括號保護參數
#define BIT_OP(addr, bit, op)  do { \
    if (op) \
        (addr) |= (1UL << (bit)); \
    else \
        (addr) &= ~(1UL << (bit)); \
} while (0)
```

或者，更進階的「表達式（Expression）」寫法（可以用於賦值）：

```c
#define BIT_OP(addr, bit, op) \
    ((op) ? ((addr) |= (1UL << (bit))) : ((addr) &= ~(1UL << (bit))))
```

-----

### 【第四題：結構體記憶體對齊 (Struct Padding & Alignment)】

這一題對應你提供資料中的 `sizeof(struct)`。在做通訊協議（Protocol）解析時，這個觀念如果錯了，資料解出來全是亂碼。

請看下面的 C 語言結構體。假設我們在一個 **32-bit 的處理器**上（`int` = 4 bytes, `char` = 1 byte, `short` = 2 bytes），且編譯器預設採樣 **4-byte Alignment**。

```c
typedef struct {
    char  a;
    int   b;
    short c;
} Data_t;
```

請回答：

1.  這個 `sizeof(Data_t)` 的結果是多少 bytes？（請畫出或描述它在記憶體中是怎麼排列的，哪裡有 Padding？）
2.  如果不希望有任何 Padding（例如這是要直接透過 UART 傳送的封包），你會如何在 C 語言中處理？（請寫出關鍵字）

我的回答:
1. 總共12bytes

###補充
3.  **關於取消 Padding (0分 - 你未回答)：**
    * 這在韌體通訊協議定義中非常重要，請務必記住這兩個關鍵字：
        * **GCC/Clang (常用)**：`__attribute__((packed))`
        * **通用/Windows/Keil**：`#pragma pack(1)` ... `#pragma pack()`
    * **資深工程師補充**：為什麼編譯器預設不 Packed？因為 **Packed 會導致非對齊存取 (Unaligned Access)**。
    * 在某些架構（如舊的 ARM Cortex-M0 或特定 DSP）上，讀取非對齊的 `int` 會直接導致硬體錯誤（**Hard Fault**）當機！在追求空間極小化時，要非常小心效能懲罰。

---

### 【第五題：資料結構與記憶體配置】

這題對應你提供資料中的第 6 點：**Array vs Linked List**。這不只是考資工導論，我要聽的是你在「資源受限」的嵌入式環境下的判斷。

請回答以下兩部分：

1.  請比較 **Array** 與 **Linked List** 在以下三個面向的差異：
    * **記憶體配置方式** (連續 vs 不連續 / Static vs Dynamic)
    * **隨機存取 (Random Access)** 的時間複雜度
    * **插入/刪除元素** 的時間複雜度

2.  **情境題（重要）**：
    假設我們現在用的 MCU RAM 只有 2KB，我們要設計一個 **UART 接收緩衝區 (Rx Buffer)** 來暫存快速進來的資料。
    你會選擇用 **Array (Ring Buffer)** 還是 **Linked List**？為什麼？（請從記憶體碎片化、效能、以及實作複雜度來分析）

我的回答:

1. - Array的記憶體是連續的 linklist不連續
   - 隨機存取的時間複雜度 Array是O(n) linklist是O(2n)
   - 插入/刪除元素的時間複雜度 Array是O(n) linklist是O(2n)
2. 我認為用linklist能節省記憶體空間。

###錯誤解析:
1. - 隨機存取的時間複雜度 Array是O(1) linklist是O(n)
   - 插入/刪除元素的時間複雜度 Array是O(n) linklist是O(1)

2. 關於 UART Buffer 的選擇 (0分 - 致命觀念錯誤)：**
* 你的選擇是 **Linked List**，理由是「節省空間」。**這在嵌入式系統中是大錯特錯的。**
    * **記憶體浪費 (Overhead)**：
        假設 UART 收進來是 1個 byte (`char`)。
        * **Array**: 存 1 個 char 佔 **1 byte**。
        * **Linked List**: 存 1 個 char，你還需要一個指向下個節點的指標 (Pointer)。在 32-bit 系統上，指標佔 4 bytes。
        * 結果：為了存 1 byte 資料，你用了 1+4 = 5 bytes。**浪費了 400% 的空間！** 這對於只有 2KB RAM 的 MCU 是自殺行為。
    * **記憶體碎片化 (Fragmentation)**：
        Linked List 需要 `malloc`。在 2KB 的小系統頻繁 `malloc/free`，很快記憶體就會變成碎片，導致系統當機。
    * **效能不確定性**：
        UART 是中斷 (ISR) 處理的，速度很快。`malloc` 的執行時間是不固定的，這在即時系統 (Real-time System) 中是大忌。

    **情境選擇 (UART Buffer)**：
    * **絕對選擇 Array (實作為 Ring Buffer / Circular Queue)**。
    * **理由**：
        1.  **無額外開銷**：不需要儲存 Next 指標，空間利用率 100%。
        2.  **穩定安全**：使用靜態陣列 (Static Array)，編譯時就佔好空間，沒有 Runtime Out of Memory 或碎片化的風險。
        3.  **效能極致**：存取都是 $O(1)$，非常適合高速的 ISR 環境。



---

### 【第六題：演算法與 Bit Manipulation】

這題對應你提供資料中的第 4 點：**Number of 1 Bits**。這是一道非常經典的面試題，用來測試你對二進位的直覺。

請寫一個 C 語言函數 `int count_set_bits(uint32_t n)`。
功能：輸入一個無號整數，回傳它的二進位表示中有幾個 **Bit 是 1**。

例如：
* 輸入 `11` (二進位 `1011`) -> 回傳 `3`
* 輸入 `128` (二進位 `10000000`) -> 回傳 `1`

**要求：**
1.  請先寫出最直覺的解法（逐位檢查）。
2.  (進階) 如果這個 function 會被呼叫幾百萬次，效能很重要。你有聽過 **Brian Kernighan's Algorithm** 嗎？能不能寫出一個比逐位檢查更快的版本？（提示：利用 `n & (n-1)`）

(請直接寫 code)

錯誤解析:
1. 關於bit的計算要用bitwise operation解決，可以直接128 & 1 或是128 >> 1 之類的。
2. 位元運算一定要使用unsigned int。
3. 題目要求撰寫函數
   
```c
#include <stdint.h>

// 版本 1: 標準逐位檢查 (修正了型別與賦值錯誤)
int count_set_bits_basic(uint32_t n) {
    int count = 0;
    while (n > 0) {
        if (n & 1) {
            count++;
        }
        n >>= 1; // 修正：必須賦值回去
    }
    return count;
}

// 版本 2: Brian Kernighan's Algorithm (高效版)
// 複雜度只與「1 的個數」有關，比逐位檢查快
int count_set_bits_optimized(uint32_t n) {
    int count = 0;
    while (n > 0) {
        n &= (n - 1); // 每次運算都會消除最低位的一個 1
        count++;
    }
    return count;
}
```

 Brian Kernighan's Algorithm
 - (num - 1)會讓最右邊的1為0，而這個1後面的數字全會變1，在和原本的自己做and運算就會使得最右邊的1消除掉。只要把 if(num & 1)         count++ ; 改成 num = num & (num - 1); count++ ;

---

### 【第七題：RTOS 與 系統架構】

我們暫時離開 Coding，來看看系統觀念。這對應你資料中的第 6 點：**Process & Thread**。

在嵌入式系統開發中，我們常會用到 RTOS (如 FreeRTOS)。
請回答以下問題：

1.  請簡單解釋 **Process (行程/進程)** 與 **Thread (執行緒)** 的主要差別是什麼？（提示：記憶體空間資源的共用性）
2.  在一般的 **MCU (Microcontroller)** 環境下跑的 RTOS (如 FreeRTOS)，我們建立的 Task 比較像是 Process 還是 Thread？為什麼？

我的回答:





